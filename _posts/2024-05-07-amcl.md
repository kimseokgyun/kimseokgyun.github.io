---
layout: post
title: AMCL
date: 2024-05-07 19:00 +0900
last_modified_at: 2024-05-07 19:00 +0900
tags: [Robot, ROS2]
toc:  true
---
## Conclusion

Particle filter를 이용한 MCL 알고리즘에서 특징점의 양상 따라 Adaptive 계수를 통해 particle을 random 하게 생성하여 Kidnap Problem 에 좀더 강인한 알고리즘이 AMCL 이다.

- MCL은 베이지안필터에서 bel(x)를 Particle로 표현한 알고리즘
- Short-term ,Long-term Average 변수를 통해  기존 Particle Filter 로는 로봇의 실제 위치에 절대 수렴하지 못하는 경우에도 Particle 을 랜덤하게 샘플링하여 복구할수있는 여지가 있다. 
- KLD-Sampling 기법을 통해 Particle 의 개수를 유동적으로 변경하여 Computing resource 낭비를 줄임
- 코드 구현시 KD Tree 자료구조를 이용하여 Particle Cluster 진행한다. 해당 Clustering 작업을통해 최종 추정위치에 따른 공분산 값도 얻는다.
- Lidar Callback Thread에서 AMCL를 돌게끔 구현하여, 알고리즘 flow에 꼬임을 방지.  Lidar는 높아봤자 20~50Hz

## Meaning

- Kalman Filter 보다 
- 

<!-- ![placeholder](http://placehold.it/800x400 "Large example image") -->

## Concept
<inv>ROS2 Humble Version 의 nav2_amcl 기반으로 amcl 이론을 코드로 어떻게 구현했는지 참고했습니다</inv>

### 노드 구성

![placeholder](/upload_image/amcl/amcl_1.png "Large example image"){: .align-center}

<center>nav2_amcl node 는 Lidar Callback Thread, 기본 Node Thread 두개의 Thread로 구성된다</center>

- Lidar Callback Thread 
  - Lidar Subscription Callback 마다 AMCL 알고리즘이 수행된다. 

- Node Thread 
  - Map Sub, Global Localization Service, NoMotion Service, Dynamic Parameter Callback 수행.


### AMCL 구현
![placeholder](/upload_image/amcl/amcl_2.png "Large example image")

![placeholder](/upload_image/amcl/amcl_3.png "Large example image")


- 4 단계로 설명한다.
  1. [Initialize Particle](####Initialize-Particle)
  2. [Simulate Particle motion](####Simulate-Particle-Motion)
  3. [Calculate particle`s score](####Calculate-particle`s-score)
  4. [Resample Particle](####Resample-Particle)







#### <center>Initialize Particle </center>[^fn-sample_footnote]

<br/>

- 각 Particle 초기위치를 선정한다. 초기위치 Pose를 선정하고 Covariance 로 Particle 을 뿌려준다

{% highlight c++ %}
// handleInitialPose in amcle_node.cpp

  // Re-initialize the filter
  pf_vector_t pf_init_pose_mean = pf_vector_zero();
  pf_init_pose_mean.v[0] = pose_new.getOrigin().x(); 
  pf_init_pose_mean.v[1] = pose_new.getOrigin().y();
  pf_init_pose_mean.v[2] = tf2::getYaw(pose_new.getRotation());
  // Copy in the covariance, converting from 6-D to 3-D
  for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 2; j++) {
      pf_init_pose_cov.m[i][j] = msg.pose.covariance[6 * i + j];
    }
  }

  pf_init_pose_cov.m[2][2] = msg.pose.covariance[6 * 5 + 5];
{% endhighlight %}

  - map 과 odom 의 tf를 만들어주고 pf(particle Filter)를 Init한다
  - odom Frame에서의 pose 의 covariance를 particle Filter의 분산으로 사용한다. 
<br/><br/>


{% highlight c++ %}
// in pf.hpp
typedef struct _pf_t
{
  // This min and max number of samples
  int min_samples, max_samples;

  // Population size parameters
  double pop_err, pop_z;

  // The sample sets.  We keep two sets and use [current_set]
  // to identify the active set.
  int current_set;
  pf_sample_set_t sets[2];

  // Running averages, slow and fast, of likelihood
  double w_slow, w_fast;

  // Decay rates for running averages
  double alpha_slow, alpha_fast;

  // Function used to draw random pose samples
  pf_init_model_fn_t random_pose_fn;
  void * random_pose_data;

  double dist_threshold;  // distance threshold in each axis over which the pf is considered to not
                          // be converged
  int converged;
} pf_t;
{% endhighlight %}

  - pf_t라는 구조체로 particle Filter 를 관리한다.
  - 하나의 파티클필터에 **w_slow**, **w_fast** 파라미터와 **alpha_slow**, **alpha_fast** Adaptive 계수를 관리한다
  - pf_sample_set_t 을 set[2] : 2개의 배열로 구현하여 두개의 particle Filter Sample군을 통해 이전정보와 현재 정보의 Particle을 개별 관리한다.

<br/><br/>

#### <center> Simulate particle Motion </center> [^fn-sample_footnote2]

- 의사코드의 5 Line **sample_motion_model** 에 해당한다. 입력  \\\(u_t\\\) 에 따른  \\\(x_(t-1)\\\) 을 Simulate한다.

- nav2_amcl 은 로봇의 입력 \\\(u_t\\\)를 Motion Delta 개념을 넣어 일정거리, 일정각도 움직였을때 Particle을 업데이트 한다.


{% highlight c++ %}
// ShouldUpdateFilter in amcl_node.cpp
  delta.v[0] = pose.v[0] - pf_odom_pose_.v[0];
  delta.v[1] = pose.v[1] - pf_odom_pose_.v[1];
  delta.v[2] = angleutils::angle_diff(pose.v[2], pf_odom_pose_.v[2]);

  // See if we should update the filter
  bool update = fabs(delta.v[0]) > d_thresh_ ||
    fabs(delta.v[1]) > d_thresh_ ||
    fabs(delta.v[2]) > a_thresh_;
  update = update || force_update_;
  return update;
{% endhighlight %}

-  \\\(x_(t-1)\\\)에 해당하는 pf_odom_pose_ 와 현재상태 \\\(x_(t)\\\)에 해당하는 pose 의 delta를 계산한다
  - d_thresh_ 파라미터 : filter update에 필요한 dx,dy threshold 
  - a_thresh_ 파라미터 : filter update에 필요한 da threshold (각도)

<br/><br/>

- Partilce Filter 업데이트시 Robot Motion Model 에 따라 Particle 들의 움직임을 예측한다.
  - Nav2_amcl에는 differential_motion_model, omni_motion_model 두가지로 구현되어있음

<br/>

#### differential_motion_model

![placeholder](/upload_image/amcl/amcl_4.png "Large example image"){: .align-center}

기본적으로 Motion Model은 Velocity Motion model, Odometry Motion Model 가 있는데, nav2_amcl에서는  Odometry Motion Model을 사용한다.

![placeholder](/upload_image/amcl/amcl_5.jpg "Large example image"){: .align-center}

- dt 단위가 아닌 , v(이동거리), a(이동각도) 에 따라 파티클의 상태를 추정한다. 
- t-1 단계에서 t 까지의 움직임을 총 3가지로 성분을 나눠서 분산의 형태를 정한다.
  - 즉 t-1 단계에서 t까지 (극단적으로) S자형태로 곡선으로 움직이더라도 t-1와 t단계의 로봇 pose로 파티클의 분산을 결정한다는 의미


{% highlight c++ %}
// ShouldUpdateFilter in amcl_node.cpp
  delta.v[0] = pose.v[0] - pf_odom_pose_.v[0];
  delta.v[1] = pose.v[1] - pf_odom_pose_.v[1];
  delta.v[2] = angleutils::angle_diff(pose.v[2], pf_odom_pose_.v[2]);

  // See if we should update the filter
  bool update = fabs(delta.v[0]) > d_thresh_ ||
    fabs(delta.v[1]) > d_thresh_ ||
    fabs(delta.v[2]) > a_thresh_;
  update = update || force_update_;
  return update;
{% endhighlight %}



#### <center> Calculate particle`s score </center>

#### <center> Resample Particle </center>